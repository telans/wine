From 2f11cd1c56436345d710d0926a0a2db481b25344 Mon Sep 17 00:00:00 2001
From: Theo Anderson <telans@posteo.de>
Date: Thu, 17 Sep 2020 13:57:39 +1200
Subject: [PATCH 1/1] 05-hotfixes

---
 dlls/kernel32/tests/process.c  |   9 +
 dlls/ntdll/file.c              |   2 +-
 dlls/ntdll/nt.c                | 296 +++++++++++++++++----------------
 dlls/ntdll/sync.c              |  20 ++-
 include/wine/server_protocol.h |  56 +++++++
 server/process.c               |  83 +++++++++
 server/protocol.def            |  39 +++++
 server/request.h               |  13 ++
 server/trace.c                 |  66 ++++++++
 9 files changed, 441 insertions(+), 143 deletions(-)

diff --git a/dlls/kernel32/tests/process.c b/dlls/kernel32/tests/process.c
index c25bb45ba7..95aec4a343 100644
--- a/dlls/kernel32/tests/process.c
+++ b/dlls/kernel32/tests/process.c
@@ -2710,6 +2710,7 @@ static void test_QueryInformationJobObject(void)
     PJOBOBJECT_BASIC_PROCESS_ID_LIST pid_list = (JOBOBJECT_BASIC_PROCESS_ID_LIST *)buf;
     JOBOBJECT_EXTENDED_LIMIT_INFORMATION ext_limit_info;
     JOBOBJECT_BASIC_LIMIT_INFORMATION *basic_limit_info = &ext_limit_info.BasicLimitInformation;
+    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION basic_accounting_info;
     DWORD ret_len;
     PROCESS_INFORMATION pi[2];
     char buffer[50];
@@ -2817,6 +2818,14 @@ static void test_QueryInformationJobObject(void)
     ok(ret_len == sizeof(ext_limit_info), "QueryInformationJobObject returned ret_len=%u\n", ret_len);
     expect_eq_d(0, basic_limit_info->LimitFlags);
 
+    /* test JobObjectBasicAccountingInformation */
+    ret = pQueryInformationJobObject(job, JobObjectBasicAccountingInformation, &basic_accounting_info,
+                                     sizeof(basic_accounting_info), &ret_len);
+    ok(ret, "QueryInformationJobObject error %u\n", GetLastError());
+    ok(ret_len == sizeof(basic_accounting_info), "QueryInformationJobObject returned ret_len=%u\n", ret_len);
+    expect_eq_d(3, basic_accounting_info.TotalProcesses);
+    expect_eq_d(2, basic_accounting_info.ActiveProcesses);
+
     TerminateProcess(pi[0].hProcess, 0);
     CloseHandle(pi[0].hProcess);
     CloseHandle(pi[0].hThread);
diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
index d05fdb74e7..44d6e72a00 100644
--- a/dlls/ntdll/file.c
+++ b/dlls/ntdll/file.c
@@ -4249,7 +4249,7 @@ NTSTATUS WINAPI NtFlushBuffersFile( HANDLE hFile, IO_STATUS_BLOCK *io )
     if (ret == STATUS_ACCESS_DENIED)
         ret = server_get_unix_fd( hFile, FILE_APPEND_DATA, &fd, &needs_close, &type, NULL );
 
-    if (!ret && (type == FD_TYPE_FILE || type == FD_TYPE_DIR))
+    if (!ret && (type == FD_TYPE_FILE || type == FD_TYPE_DIR || type == FD_TYPE_CHAR))
     {
         if (fsync(fd))
             ret = FILE_GetNtStatus();
diff --git a/dlls/ntdll/nt.c b/dlls/ntdll/nt.c
index 52161a3abc..3ef7f110cf 100644
--- a/dlls/ntdll/nt.c
+++ b/dlls/ntdll/nt.c
@@ -135,6 +135,12 @@ struct smbios_board {
     BYTE product;
     BYTE version;
     BYTE serial;
+    BYTE asset_tag;
+    BYTE feature_flags;
+    BYTE location;
+    WORD chassis_handle;
+    BYTE board_type;
+    BYTE num_contained_handles;
 };
 
 struct smbios_chassis {
@@ -148,6 +154,18 @@ struct smbios_chassis {
     BYTE power_supply_state;
     BYTE thermal_state;
     BYTE security_status;
+    DWORD oem_defined;
+    BYTE height;
+    BYTE num_power_cords;
+    BYTE num_contained_elements;
+    BYTE contained_element_rec_length;
+};
+
+struct smbios_boot_info
+{
+    struct smbios_header hdr;
+    BYTE reserved[6];
+    BYTE boot_status[10];
 };
 
 #include "poppack.h"
@@ -2247,18 +2265,21 @@ static NTSTATUS get_firmware_info(SYSTEM_FIRMWARE_TABLE_INFORMATION *sfti, ULONG
             size_t system_vendor_len, system_product_len, system_version_len, system_serial_len;
             char system_sku[128], system_family[128];
             size_t system_sku_len, system_family_len;
-            char board_vendor[128], board_product[128], board_version[128], board_serial[128];
-            size_t board_vendor_len, board_product_len, board_version_len, board_serial_len;
+            char board_vendor[128], board_product[128], board_version[128], board_serial[128], board_asset_tag[128];
+            size_t board_vendor_len, board_product_len, board_version_len, board_serial_len, board_asset_tag_len;
             char chassis_vendor[128], chassis_version[128], chassis_serial[128], chassis_asset_tag[128];
             char chassis_type[11] = "2"; /* unknown */
             size_t chassis_vendor_len, chassis_version_len, chassis_serial_len, chassis_asset_tag_len;
             char *buffer = (char*)sfti->TableBuffer;
             BYTE string_count;
+            BYTE handle_count = 0;
             struct smbios_prologue *prologue;
             struct smbios_bios *bios;
             struct smbios_system *system;
             struct smbios_board *board;
             struct smbios_chassis *chassis;
+            struct smbios_boot_info *boot_info;
+            struct smbios_header *end_of_table;
 
 #define S(s) s, sizeof(s)
             bios_vendor_len = get_smbios_string("/sys/class/dmi/id/bios_vendor", S(bios_vendor));
@@ -2274,6 +2295,7 @@ static NTSTATUS get_firmware_info(SYSTEM_FIRMWARE_TABLE_INFORMATION *sfti, ULONG
             board_product_len = get_smbios_string("/sys/class/dmi/id/board_name", S(board_product));
             board_version_len = get_smbios_string("/sys/class/dmi/id/board_version", S(board_version));
             board_serial_len = get_smbios_string("/sys/class/dmi/id/board_serial", S(board_serial));
+            board_asset_tag_len = get_smbios_string("/sys/class/dmi/id/board_asset_tag", S(board_asset_tag));
             chassis_vendor_len = get_smbios_string("/sys/class/dmi/id/chassis_vendor", S(chassis_vendor));
             chassis_version_len = get_smbios_string("/sys/class/dmi/id/chassis_version", S(chassis_version));
             chassis_serial_len = get_smbios_string("/sys/class/dmi/id/chassis_serial", S(chassis_serial));
@@ -2292,11 +2314,18 @@ static NTSTATUS get_firmware_info(SYSTEM_FIRMWARE_TABLE_INFORMATION *sfti, ULONG
                                  L(system_serial_len) + L(system_sku_len) + L(system_family_len) + 1, 2);
 
             *required_len += sizeof(struct smbios_board);
-            *required_len += max(L(board_vendor_len) + L(board_product_len) + L(board_version_len) + L(board_serial_len) + 1, 2);
+            *required_len += max(L(board_vendor_len) + L(board_product_len) + L(board_version_len) +
+                                 L(board_serial_len) + L(board_asset_tag_len) + 1, 2);
 
             *required_len += sizeof(struct smbios_chassis);
             *required_len += max(L(chassis_vendor_len) + L(chassis_version_len) + L(chassis_serial_len) +
                                  L(chassis_asset_tag_len) + 1, 2);
+
+            *required_len += sizeof(struct smbios_boot_info);
+            *required_len += 2;
+
+            *required_len += sizeof(struct smbios_header);
+            *required_len += 2;
 #undef L
 
             sfti->TableBufferLength = *required_len;
@@ -2318,7 +2347,7 @@ static NTSTATUS get_firmware_info(SYSTEM_FIRMWARE_TABLE_INFORMATION *sfti, ULONG
             bios = (struct smbios_bios*)buffer;
             bios->hdr.type = 0;
             bios->hdr.length = sizeof(struct smbios_bios);
-            bios->hdr.handle = 0;
+            bios->hdr.handle = handle_count++;
             bios->vendor = bios_vendor_len ? ++string_count : 0;
             bios->version = bios_version_len ? ++string_count : 0;
             bios->start = 0;
@@ -2343,7 +2372,7 @@ static NTSTATUS get_firmware_info(SYSTEM_FIRMWARE_TABLE_INFORMATION *sfti, ULONG
             system = (struct smbios_system*)buffer;
             system->hdr.type = 1;
             system->hdr.length = sizeof(struct smbios_system);
-            system->hdr.handle = 0;
+            system->hdr.handle = handle_count++;
             system->vendor = system_vendor_len ? ++string_count : 0;
             system->product = system_product_len ? ++string_count : 0;
             system->version = system_version_len ? ++string_count : 0;
@@ -2363,29 +2392,11 @@ static NTSTATUS get_firmware_info(SYSTEM_FIRMWARE_TABLE_INFORMATION *sfti, ULONG
             if (!string_count) *buffer++ = 0;
             *buffer++ = 0;
 
-            string_count = 0;
-            board = (struct smbios_board*)buffer;
-            board->hdr.type = 2;
-            board->hdr.length = sizeof(struct smbios_board);
-            board->hdr.handle = 0;
-            board->vendor = board_vendor_len ? ++string_count : 0;
-            board->product = board_product_len ? ++string_count : 0;
-            board->version = board_version_len ? ++string_count : 0;
-            board->serial = board_serial_len ? ++string_count : 0;
-            buffer += sizeof(struct smbios_board);
-
-            copy_smbios_string(&buffer, board_vendor, board_vendor_len);
-            copy_smbios_string(&buffer, board_product, board_product_len);
-            copy_smbios_string(&buffer, board_version, board_version_len);
-            copy_smbios_string(&buffer, board_serial, board_serial_len);
-            if (!string_count) *buffer++ = 0;
-            *buffer++ = 0;
-
             string_count = 0;
             chassis = (struct smbios_chassis*)buffer;
             chassis->hdr.type = 3;
             chassis->hdr.length = sizeof(struct smbios_chassis);
-            chassis->hdr.handle = 0;
+            chassis->hdr.handle = handle_count++;
             chassis->vendor = chassis_vendor_len ? ++string_count : 0;
             chassis->type = atoi(chassis_type);
             chassis->version = chassis_version_len ? ++string_count : 0;
@@ -2395,6 +2406,11 @@ static NTSTATUS get_firmware_info(SYSTEM_FIRMWARE_TABLE_INFORMATION *sfti, ULONG
             chassis->power_supply_state = 0x02; /* unknown */
             chassis->thermal_state = 0x02; /* unknown */
             chassis->security_status = 0x02; /* unknown */
+            chassis->oem_defined = 0;
+            chassis->height = 0; /* undefined */
+            chassis->num_power_cords = 0; /* unspecified */
+            chassis->num_contained_elements = 0;
+            chassis->contained_element_rec_length = 3;
             buffer += sizeof(struct smbios_chassis);
 
             copy_smbios_string(&buffer, chassis_vendor, chassis_vendor_len);
@@ -2404,6 +2420,49 @@ static NTSTATUS get_firmware_info(SYSTEM_FIRMWARE_TABLE_INFORMATION *sfti, ULONG
             if (!string_count) *buffer++ = 0;
             *buffer++ = 0;
 
+            string_count = 0;
+            board = (struct smbios_board*)buffer;
+            board->hdr.type = 2;
+            board->hdr.length = sizeof(struct smbios_board);
+            board->hdr.handle = handle_count++;
+            board->vendor = board_vendor_len ? ++string_count : 0;
+            board->product = board_product_len ? ++string_count : 0;
+            board->version = board_version_len ? ++string_count : 0;
+            board->serial = board_serial_len ? ++string_count : 0;
+            board->asset_tag = board_asset_tag_len ? ++string_count : 0;
+            board->feature_flags = 0x5; /* hosting board, removable */
+            board->location = 0;
+            board->chassis_handle = chassis->hdr.handle;
+            board->board_type = 0xa; /* motherboard */
+            board->num_contained_handles = 0;
+            buffer += sizeof(struct smbios_board);
+
+            copy_smbios_string(&buffer, board_vendor, board_vendor_len);
+            copy_smbios_string(&buffer, board_product, board_product_len);
+            copy_smbios_string(&buffer, board_version, board_version_len);
+            copy_smbios_string(&buffer, board_serial, board_serial_len);
+            copy_smbios_string(&buffer, board_asset_tag, board_asset_tag_len);
+            if (!string_count) *buffer++ = 0;
+            *buffer++ = 0;
+
+            boot_info = (struct smbios_boot_info*)buffer;
+            boot_info->hdr.type = 32;
+            boot_info->hdr.length = sizeof(struct smbios_boot_info);
+            boot_info->hdr.handle = handle_count++;
+            memset(boot_info->reserved, 0, sizeof(boot_info->reserved));
+            memset(boot_info->boot_status, 0, sizeof(boot_info->boot_status)); /* no errors detected */
+            buffer += sizeof(struct smbios_boot_info);
+            *buffer++ = 0;
+            *buffer++ = 0;
+
+            end_of_table = (struct smbios_header*)buffer;
+            end_of_table->type = 127;
+            end_of_table->length = sizeof(struct smbios_header);
+            end_of_table->handle = handle_count++;
+            buffer += sizeof(struct smbios_header);
+            *buffer++ = 0;
+            *buffer++ = 0;
+
             return STATUS_SUCCESS;
         }
     default:
@@ -2763,141 +2822,100 @@ NTSTATUS WINAPI NtQuerySystemInformation(
         break;
     case SystemProcessInformation:
         {
-            SYSTEM_PROCESS_INFORMATION* spi = SystemInformation;
-            SYSTEM_PROCESS_INFORMATION* last = NULL;
-            unsigned long clk_tck = sysconf(_SC_CLK_TCK);
-            HANDLE hSnap = 0;
-            WCHAR procname[1024];
-            WCHAR* exename;
-            DWORD wlen = 0;
-            DWORD procstructlen = 0;
-            int unix_pid = -1;
-
-            SERVER_START_REQ( create_snapshot )
+            unsigned int process_count, i, j;
+            char *buffer = NULL;
+            unsigned int pos = 0;
+            if (Length && !(buffer = RtlAllocateHeap( GetProcessHeap(), 0, Length )))
             {
-                req->flags      = SNAP_PROCESS | SNAP_THREAD;
-                req->attributes = 0;
-                if (!(ret = wine_server_call( req )))
-                    hSnap = wine_server_ptr_handle( reply->handle );
+                ret = STATUS_NO_MEMORY;
+                break;
+            }
+
+            SERVER_START_REQ( list_processes )
+            {
+                wine_server_set_reply( req, buffer, Length );
+                ret = wine_server_call( req );
+                len = reply->info_size;
+                process_count = reply->process_count;
             }
             SERVER_END_REQ;
+
+            if (ret)
+            {
+                RtlFreeHeap( GetProcessHeap(), 0, buffer );
+                break;
+            }
+
             len = 0;
-            while (ret == STATUS_SUCCESS)
+
+            for (i = 0; i < process_count; i++)
             {
-                SERVER_START_REQ( next_process )
+                SYSTEM_PROCESS_INFORMATION *nt_process = (SYSTEM_PROCESS_INFORMATION *)((char *)SystemInformation + len);
+                const struct process_info *server_process;
+                const WCHAR *server_name, *file_part;
+                ULONG proc_len;
+                ULONG name_len = 0;
+
+                pos = (pos + 7) & ~7;
+                server_process = (const struct process_info *)(buffer + pos);
+                pos += sizeof(*server_process);
+
+                server_name = (const WCHAR *)(buffer + pos);
+                file_part = server_name + (server_process->name_len / sizeof(WCHAR));
+                pos += server_process->name_len;
+                while (file_part > server_name && file_part[-1] != '\\')
                 {
-                    req->handle = wine_server_obj_handle( hSnap );
-                    req->reset = (len == 0);
-                    wine_server_set_reply( req, procname, sizeof(procname)-sizeof(WCHAR) );
-                    if (!(ret = wine_server_call( req )))
-                    {
-                        /* Make sure procname is 0 terminated */
-                        procname[wine_server_reply_size(reply) / sizeof(WCHAR)] = 0;
-
-                        /* Get only the executable name, not the path */
-                        if ((exename = wcsrchr(procname, '\\')) != NULL) exename++;
-                        else exename = procname;
-
-                        wlen = (wcslen(exename) + 1) * sizeof(WCHAR);
-
-                        procstructlen = sizeof(*spi) + wlen + ((reply->threads - 1) * sizeof(SYSTEM_THREAD_INFORMATION));
-
-                        if (Length >= len + procstructlen)
-                        {
-                            /* ftCreationTime;
-                             * vmCounters, ioCounters
-                             */
- 
-                            memset(spi, 0, sizeof(*spi));
-
-                            spi->NextEntryOffset = procstructlen - wlen;
-                            spi->dwThreadCount = reply->threads;
-
-                            /* spi->pszProcessName will be set later on */
-
-                            spi->dwBasePriority = reply->priority;
-                            spi->UniqueProcessId = UlongToHandle(reply->pid);
-                            spi->ParentProcessId = UlongToHandle(reply->ppid);
-                            spi->HandleCount = reply->handles;
-                            spi->CreationTime.QuadPart = reply->start_time;
-
-                            /* spi->ti will be set later on */
-
-                            if (reply->unix_pid != -1)
-                            {
-                                read_process_time(reply->unix_pid, -1, clk_tck,
-                                                  &spi->KernelTime, &spi->UserTime);
-                                read_process_memory_stats(reply->unix_pid, &spi->vmCounters);
-                            }
-                            unix_pid = reply->unix_pid;
-                        }
-                        len += procstructlen;
-                    }
+                    file_part--;
+                    name_len++;
                 }
-                SERVER_END_REQ;
- 
-                if (ret != STATUS_SUCCESS)
+
+                proc_len = sizeof(*nt_process) + server_process->thread_count * sizeof(SYSTEM_THREAD_INFORMATION)
+                             + (name_len + 1) * sizeof(WCHAR);
+                len += proc_len;
+
+                if (len <= Length)
                 {
-                    if (ret == STATUS_NO_MORE_FILES) ret = STATUS_SUCCESS;
-                    break;
+                    memset(nt_process, 0, sizeof(*nt_process));
+                    if (i < process_count - 1)
+                        nt_process->NextEntryOffset = proc_len;
+                    nt_process->dwThreadCount = server_process->thread_count;
+                    nt_process->dwBasePriority = server_process->priority;
+                    nt_process->UniqueProcessId = UlongToHandle(server_process->pid);
+                    nt_process->ParentProcessId = UlongToHandle(server_process->parent_pid);
+                    nt_process->HandleCount = server_process->handle_count;
                 }
 
-                if (Length >= len)
+                pos = (pos + 7) & ~7;
+                for (j = 0; j < server_process->thread_count; j++)
                 {
-                    int     i, j;
+                    const struct thread_info *server_thread = (const struct thread_info *)(buffer + pos);
 
-                    /* set thread info */
-                    i = j = 0;
-                    while (ret == STATUS_SUCCESS)
+                    if (len <= Length)
                     {
-                        SERVER_START_REQ( next_thread )
-                        {
-                            req->handle = wine_server_obj_handle( hSnap );
-                            req->reset = (j == 0);
-                            if (!(ret = wine_server_call( req )))
-                            {
-                                j++;
-                                if (UlongToHandle(reply->pid) == spi->UniqueProcessId)
-                                {
-                                    /* ftKernelTime, ftUserTime, ftCreateTime;
-                                     * dwTickCount, dwStartAddress
-                                     */
-
-                                    memset(&spi->ti[i], 0, sizeof(spi->ti));
-
-                                    spi->ti[i].CreateTime.QuadPart = reply->creation_time;
-                                    spi->ti[i].ClientId.UniqueProcess = UlongToHandle(reply->pid);
-                                    spi->ti[i].ClientId.UniqueThread  = UlongToHandle(reply->tid);
-                                    spi->ti[i].dwCurrentPriority = reply->base_pri + reply->delta_pri;
-                                    spi->ti[i].dwBasePriority = reply->base_pri;
-
-                                    if (unix_pid != -1 && reply->unix_tid != -1)
-                                        read_process_time(unix_pid, reply->unix_tid, clk_tck,
-                                                          &spi->ti[i].KernelTime, &spi->ti[i].UserTime);
-                                    i++;
-                                }
-                            }
-                        }
-                        SERVER_END_REQ;
+                        nt_process->ti[j].CreateTime.QuadPart = 0xdeadbeef;
+                        nt_process->ti[j].ClientId.UniqueProcess = UlongToHandle(server_process->pid);
+                        nt_process->ti[j].ClientId.UniqueThread = UlongToHandle(server_thread->tid);
+                        nt_process->ti[j].dwCurrentPriority = server_thread->current_priority;
+                        nt_process->ti[j].dwBasePriority = server_thread->base_priority;
                     }
-                    if (ret == STATUS_NO_MORE_FILES) ret = STATUS_SUCCESS;
 
-                    /* now append process name */
-                    spi->ProcessName.Buffer = (WCHAR*)((char*)spi + spi->NextEntryOffset);
-                    spi->ProcessName.Length = wlen - sizeof(WCHAR);
-                    spi->ProcessName.MaximumLength = wlen;
-                    memcpy( spi->ProcessName.Buffer, exename, wlen );
-                    spi->NextEntryOffset += wlen;
+                    pos += sizeof(*server_thread);
+                }
 
-                    last = spi;
-                    spi = (SYSTEM_PROCESS_INFORMATION*)((char*)spi + spi->NextEntryOffset);
+                if (len <= Length)
+                {
+                    nt_process->ProcessName.Buffer = (WCHAR *)&nt_process->ti[server_process->thread_count];
+                    nt_process->ProcessName.Length = name_len * sizeof(WCHAR);
+                    nt_process->ProcessName.MaximumLength = (name_len + 1) * sizeof(WCHAR);
+                    memcpy(nt_process->ProcessName.Buffer, file_part, name_len * sizeof(WCHAR));
+                    nt_process->ProcessName.Buffer[name_len] = 0;
                 }
             }
-            if (ret == STATUS_SUCCESS && last) last->NextEntryOffset = 0;
+
             if (len > Length) ret = STATUS_INFO_LENGTH_MISMATCH;
-            if (hSnap) NtClose(hSnap);
+            RtlFreeHeap( GetProcessHeap(), 0, buffer );
+	    break;
         }
-        break;
     case SystemProcessorPerformanceInformation:
         {
             SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION *sppi = NULL;
diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index 7763b7b4c4..8a2dd620ec 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -751,7 +751,9 @@ NTSTATUS WINAPI NtTerminateJobObject( HANDLE handle, NTSTATUS status )
 NTSTATUS WINAPI NtQueryInformationJobObject( HANDLE handle, JOBOBJECTINFOCLASS class, PVOID info,
                                              ULONG len, PULONG ret_len )
 {
-    FIXME( "stub: %p %u %p %u %p\n", handle, class, info, len, ret_len );
+    NTSTATUS ret;
+
+    TRACE( "semi-stub: %p %u %p %u %p\n", handle, class, info, len, ret_len );
 
     if (class >= MaxJobObjectInfoClass)
         return STATUS_INVALID_PARAMETER;
@@ -765,9 +767,21 @@ NTSTATUS WINAPI NtQueryInformationJobObject( HANDLE handle, JOBOBJECTINFOCLASS c
                 return STATUS_INFO_LENGTH_MISMATCH;
 
             accounting = (JOBOBJECT_BASIC_ACCOUNTING_INFORMATION *)info;
-            memset(accounting, 0, sizeof(*accounting));
+
+            SERVER_START_REQ(get_job_info)
+            {
+                req->handle = wine_server_obj_handle( handle );
+                if ((ret = wine_server_call( req )) == STATUS_SUCCESS)
+                {
+                    memset(accounting, 0, sizeof(*accounting));
+                    accounting->TotalProcesses = reply->total_processes;
+                    accounting->ActiveProcesses = reply->active_processes;
+                }
+            }
+            SERVER_END_REQ;
+
             if (ret_len) *ret_len = sizeof(*accounting);
-            return STATUS_SUCCESS;
+            return ret;
         }
 
     case JobObjectBasicProcessIdList:
diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index 41d40ee728..4d78e00ce5 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -2584,6 +2584,42 @@ struct next_thread_reply
 };
 
 
+struct thread_info
+{
+    thread_id_t     tid;
+    int             base_priority;
+    int             current_priority;
+    int             unix_tid;
+};
+
+struct process_info
+{
+    data_size_t     name_len;
+    int             thread_count;
+    int             priority;
+    process_id_t    pid;
+    process_id_t    parent_pid;
+    int             handle_count;
+    int             unix_pid;
+
+
+};
+
+
+struct list_processes_request
+{
+    struct request_header __header;
+    char __pad_12[4];
+};
+struct list_processes_reply
+{
+    struct reply_header __header;
+    data_size_t     info_size;
+    int             process_count;
+    /* VARARG(data,process_info,info_size); */
+};
+
+
 
 struct wait_debug_event_request
 {
@@ -5959,6 +5995,20 @@ struct set_job_completion_port_reply
 
 
 
+struct get_job_info_request
+{
+    struct request_header __header;
+    obj_handle_t handle;
+};
+struct get_job_info_reply
+{
+    struct reply_header __header;
+    int total_processes;
+    int active_processes;
+};
+
+
+
 struct terminate_job_request
 {
     struct request_header __header;
@@ -6199,6 +6249,7 @@ enum request
     REQ_create_snapshot,
     REQ_next_process,
     REQ_next_thread,
+    REQ_list_processes,
     REQ_wait_debug_event,
     REQ_queue_exception_event,
     REQ_get_exception_status,
@@ -6404,6 +6455,7 @@ enum request
     REQ_process_in_job,
     REQ_set_job_limits,
     REQ_set_job_completion_port,
+    REQ_get_job_info,
     REQ_terminate_job,
     REQ_suspend_process,
     REQ_resume_process,
@@ -6520,6 +6572,7 @@ union generic_request
     struct create_snapshot_request create_snapshot_request;
     struct next_process_request next_process_request;
     struct next_thread_request next_thread_request;
+    struct list_processes_request list_processes_request;
     struct wait_debug_event_request wait_debug_event_request;
     struct queue_exception_event_request queue_exception_event_request;
     struct get_exception_status_request get_exception_status_request;
@@ -6725,6 +6778,7 @@ union generic_request
     struct process_in_job_request process_in_job_request;
     struct set_job_limits_request set_job_limits_request;
     struct set_job_completion_port_request set_job_completion_port_request;
+    struct get_job_info_request get_job_info_request;
     struct terminate_job_request terminate_job_request;
     struct suspend_process_request suspend_process_request;
     struct resume_process_request resume_process_request;
@@ -6839,6 +6893,7 @@ union generic_reply
     struct create_snapshot_reply create_snapshot_reply;
     struct next_process_reply next_process_reply;
     struct next_thread_reply next_thread_reply;
+    struct list_processes_reply list_processes_reply;
     struct wait_debug_event_reply wait_debug_event_reply;
     struct queue_exception_event_reply queue_exception_event_reply;
     struct get_exception_status_reply get_exception_status_reply;
@@ -7044,6 +7099,7 @@ union generic_reply
     struct process_in_job_reply process_in_job_reply;
     struct set_job_limits_reply set_job_limits_reply;
     struct set_job_completion_port_reply set_job_completion_port_reply;
+    struct get_job_info_reply get_job_info_reply;
     struct terminate_job_reply terminate_job_reply;
     struct suspend_process_reply suspend_process_reply;
     struct resume_process_reply resume_process_reply;
diff --git a/server/process.c b/server/process.c
index 3d3aca98d2..40cd91026e 100644
--- a/server/process.c
+++ b/server/process.c
@@ -22,6 +22,7 @@
 #include "wine/port.h"
 
 #include <assert.h>
+#include <errno.h>
 #include <limits.h>
 #include <signal.h>
 #include <string.h>
@@ -162,6 +163,7 @@ struct job
     struct object obj;             /* object header */
     struct list process_list;      /* list of all processes */
     int num_processes;             /* count of running processes */
+    int total_processes;           /* count of processes which have been assigned */
     unsigned int limit_flags;      /* limit flags */
     int terminating;               /* job is terminating */
     int signaled;                  /* job is signaled */
@@ -206,6 +208,7 @@ static struct job *create_job_object( struct object *root, const struct unicode_
             /* initialize it if it didn't already exist */
             list_init( &job->process_list );
             job->num_processes = 0;
+            job->total_processes = 0;
             job->limit_flags = 0;
             job->terminating = 0;
             job->signaled = 0;
@@ -247,6 +250,7 @@ static void add_job_process( struct job *job, struct process *process )
     process->job = (struct job *)grab_object( job );
     list_add_tail( &job->process_list, &process->job_entry );
     job->num_processes++;
+    job->total_processes++;
 
     add_job_completion( job, JOB_OBJECT_MSG_NEW_PROCESS, get_process_id(process) );
 }
@@ -1787,6 +1791,18 @@ DECL_HANDLER(process_in_job)
     release_object( process );
 }
 
+/* retrieve information about a job */
+DECL_HANDLER(get_job_info)
+{
+    struct job *job = get_job_obj( current->process, req->handle, JOB_OBJECT_QUERY );
+
+    if (!job) return;
+
+    reply->total_processes = job->total_processes;
+    reply->active_processes = job->num_processes;
+    release_object( job );
+}
+
 /* terminate all processes associated with the job */
 DECL_HANDLER(terminate_job)
 {
@@ -1882,3 +1898,70 @@ DECL_HANDLER(get_system_info)
         reply->handles += get_handle_table_count( process );
     }
 }
+
+/* Get a list of processes and threads currently running */
+DECL_HANDLER(list_processes)
+{
+    struct process *process;
+    struct thread *thread;
+    unsigned int pos = 0;
+    char *buffer;
+
+    reply->process_count = 0;
+    reply->info_size = 0;
+
+    LIST_FOR_EACH_ENTRY( process, &process_list, struct process, entry )
+    {
+        struct process_dll *exe = get_process_exe_module( process );
+        reply->info_size = (reply->info_size + 7) & ~7;
+        reply->info_size += sizeof(struct process_info);
+        if (exe) reply->info_size += exe->namelen;
+        reply->info_size = (reply->info_size + 7) & ~7;
+        reply->info_size += process->running_threads * sizeof(struct thread_info);
+        reply->process_count++;
+    }
+
+    if (reply->info_size > get_reply_max_size())
+    {
+        set_error( STATUS_INFO_LENGTH_MISMATCH );
+        return;
+    }
+
+    if (!(buffer = set_reply_data_size( reply->info_size ))) return;
+
+    memset( buffer, 0, reply->info_size );
+    LIST_FOR_EACH_ENTRY( process, &process_list, struct process, entry )
+    {
+        struct process_info *process_info;
+        struct process_dll *exe = get_process_exe_module( process );
+
+        pos = (pos + 7) & ~7;
+        process_info = (struct process_info *)(buffer + pos);
+        process_info->name_len = exe ? exe->namelen : 0;
+        process_info->thread_count = process->running_threads;
+        process_info->priority = process->priority;
+        process_info->pid = process->id;
+        process_info->parent_pid = process->parent_id;
+        process_info->handle_count = get_handle_table_count(process);
+        process_info->unix_pid = process->unix_pid;
+        pos += sizeof(*process_info);
+
+        if (exe)
+        {
+            memcpy( buffer + pos, exe->filename, exe->namelen );
+            pos += exe->namelen;
+        }
+
+        pos = (pos + 7) & ~7;
+        LIST_FOR_EACH_ENTRY( thread, &process->thread_list, struct thread, proc_entry )
+        {
+            struct thread_info *thread_info = (struct thread_info *)(buffer + pos);
+
+            thread_info->tid = thread->id;
+            thread_info->base_priority = thread->priority;
+            thread_info->current_priority = thread->priority; /* FIXME */
+            thread_info->unix_tid = thread->unix_tid;
+            pos += sizeof(*thread_info);
+        }
+    }
+}
diff --git a/server/protocol.def b/server/protocol.def
index a29aa7051b..6b1b74dcab 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -1977,6 +1977,36 @@ enum char_info_mode
 @END
 
 
+struct thread_info
+{
+    thread_id_t     tid;
+    int             base_priority;
+    int             current_priority;
+    int             unix_tid;
+};
+
+struct process_info
+{
+    data_size_t     name_len;
+    int             thread_count;
+    int             priority;
+    process_id_t    pid;
+    process_id_t    parent_pid;
+    int             handle_count;
+    int             unix_pid;
+    /* VARARG(name,unicode_str,name_len); */
+    /* VARARG(threads,struct thread_info,thread_count); */
+};
+
+/* Get a list of processes and threads currently running */
+@REQ(list_processes)
+@REPLY
+    data_size_t     info_size;
+    int             process_count;
+    VARARG(data,process_info,info_size);
+@END
+
+
 /* Wait for a debug event */
 @REQ(wait_debug_event)
     int           get_handle;  /* should we alloc a handle for waiting? */
@@ -4071,6 +4101,15 @@ struct handle_info
 @END
 
 
+/* Retrieve information about a job */
+@REQ(get_job_info)
+    obj_handle_t handle;          /* handle to the job */
+@REPLY
+    int total_processes;          /* total count of processes */
+    int active_processes;         /* count of running processes */
+@END
+
+
 /* Terminate all processes associated with the job  */
 @REQ(terminate_job)
     obj_handle_t handle;          /* handle to the job */
diff --git a/server/request.h b/server/request.h
index 5c03c7d888..5e6deb45dd 100644
--- a/server/request.h
+++ b/server/request.h
@@ -219,6 +219,7 @@ DECL_HANDLER(is_same_mapping);
 DECL_HANDLER(create_snapshot);
 DECL_HANDLER(next_process);
 DECL_HANDLER(next_thread);
+DECL_HANDLER(list_processes);
 DECL_HANDLER(wait_debug_event);
 DECL_HANDLER(queue_exception_event);
 DECL_HANDLER(get_exception_status);
@@ -424,6 +425,7 @@ DECL_HANDLER(assign_job);
 DECL_HANDLER(process_in_job);
 DECL_HANDLER(set_job_limits);
 DECL_HANDLER(set_job_completion_port);
+DECL_HANDLER(get_job_info);
 DECL_HANDLER(terminate_job);
 DECL_HANDLER(suspend_process);
 DECL_HANDLER(resume_process);
@@ -539,6 +541,7 @@ static const req_handler req_handlers[REQ_NB_REQUESTS] =
     (req_handler)req_create_snapshot,
     (req_handler)req_next_process,
     (req_handler)req_next_thread,
+    (req_handler)req_list_processes,
     (req_handler)req_wait_debug_event,
     (req_handler)req_queue_exception_event,
     (req_handler)req_get_exception_status,
@@ -744,6 +747,7 @@ static const req_handler req_handlers[REQ_NB_REQUESTS] =
     (req_handler)req_process_in_job,
     (req_handler)req_set_job_limits,
     (req_handler)req_set_job_completion_port,
+    (req_handler)req_get_job_info,
     (req_handler)req_terminate_job,
     (req_handler)req_suspend_process,
     (req_handler)req_resume_process,
@@ -1415,6 +1419,10 @@ C_ASSERT( FIELD_OFFSET(struct next_thread_reply, base_pri) == 32 );
 C_ASSERT( FIELD_OFFSET(struct next_thread_reply, delta_pri) == 36 );
 C_ASSERT( FIELD_OFFSET(struct next_thread_reply, unix_tid) == 40 );
 C_ASSERT( sizeof(struct next_thread_reply) == 48 );
+C_ASSERT( sizeof(struct list_processes_request) == 16 );
+C_ASSERT( FIELD_OFFSET(struct list_processes_reply, info_size) == 8 );
+C_ASSERT( FIELD_OFFSET(struct list_processes_reply, process_count) == 12 );
+C_ASSERT( sizeof(struct list_processes_reply) == 16 );
 C_ASSERT( FIELD_OFFSET(struct wait_debug_event_request, get_handle) == 12 );
 C_ASSERT( sizeof(struct wait_debug_event_request) == 16 );
 C_ASSERT( FIELD_OFFSET(struct wait_debug_event_reply, pid) == 8 );
@@ -2526,6 +2534,11 @@ C_ASSERT( FIELD_OFFSET(struct set_job_completion_port_request, job) == 12 );
 C_ASSERT( FIELD_OFFSET(struct set_job_completion_port_request, port) == 16 );
 C_ASSERT( FIELD_OFFSET(struct set_job_completion_port_request, key) == 24 );
 C_ASSERT( sizeof(struct set_job_completion_port_request) == 32 );
+C_ASSERT( FIELD_OFFSET(struct get_job_info_request, handle) == 12 );
+C_ASSERT( sizeof(struct get_job_info_request) == 16 );
+C_ASSERT( FIELD_OFFSET(struct get_job_info_reply, total_processes) == 8 );
+C_ASSERT( FIELD_OFFSET(struct get_job_info_reply, active_processes) == 12 );
+C_ASSERT( sizeof(struct get_job_info_reply) == 16 );
 C_ASSERT( FIELD_OFFSET(struct terminate_job_request, handle) == 12 );
 C_ASSERT( FIELD_OFFSET(struct terminate_job_request, status) == 16 );
 C_ASSERT( sizeof(struct terminate_job_request) == 24 );
diff --git a/server/trace.c b/server/trace.c
index 2a72c2b6a9..bc35a2ccbb 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -1120,6 +1120,44 @@ static void dump_varargs_token_groups( const char *prefix, data_size_t size )
     fputc( '}', stderr );
 }
 
+static void dump_varargs_process_info( const char *prefix, data_size_t size )
+{
+    data_size_t pos = 0;
+    unsigned int i;
+
+    fprintf( stderr,"%s{", prefix );
+
+    while (size - pos >= sizeof(struct process_info))
+    {
+        const struct process_info *process;
+        pos = (pos + 7) & ~7;
+        process = (const struct process_info *)((const char *)cur_data + pos);
+        if (size - pos < sizeof(*process)) break;
+        if (pos) fputc( ',', stderr );
+        fprintf( stderr, "{thread_count=%u,priority=%d,pid=%04x,parent_pid=%04x,handle_count=%u,unix_pid=%d,",
+                 process->thread_count, process->priority, process->pid,
+                 process->parent_pid, process->handle_count, process->unix_pid );
+        pos += sizeof(*process);
+
+        pos = dump_inline_unicode_string( "name=L\"", pos, process->name_len, size );
+
+        pos = (pos + 7) & ~7;
+        fprintf( stderr, "\",threads={" );
+        for (i = 0; i < process->thread_count; i++)
+        {
+            const struct thread_info *thread = (const struct thread_info *)((const char *)cur_data + pos);
+            if (size - pos < sizeof(*thread)) break;
+            if (i) fputc( ',', stderr );
+            fprintf( stderr, "{tid=%04x,base_priority=%d,current_priority=%d,unix_tid=%d}",
+                     thread->tid, thread->base_priority, thread->current_priority, thread->unix_tid );
+            pos += sizeof(*thread);
+        }
+        fprintf( stderr, "}}" );
+    }
+    fputc( '}', stderr );
+    remove_data( size );
+}
+
 static void dump_varargs_object_attributes( const char *prefix, data_size_t size )
 {
     const struct object_attributes *objattr = cur_data;
@@ -2450,6 +2488,17 @@ static void dump_next_thread_reply( const struct next_thread_reply *req )
     fprintf( stderr, ", unix_tid=%d", req->unix_tid );
 }
 
+static void dump_list_processes_request( const struct list_processes_request *req )
+{
+}
+
+static void dump_list_processes_reply( const struct list_processes_reply *req )
+{
+    fprintf( stderr, " info_size=%u", req->info_size );
+    fprintf( stderr, ", process_count=%d", req->process_count );
+    dump_varargs_process_info( ", data=", min(cur_size,req->info_size) );
+}
+
 static void dump_wait_debug_event_request( const struct wait_debug_event_request *req )
 {
     fprintf( stderr, " get_handle=%d", req->get_handle );
@@ -4701,6 +4750,17 @@ static void dump_set_job_completion_port_request( const struct set_job_completio
     dump_uint64( ", key=", &req->key );
 }
 
+static void dump_get_job_info_request( const struct get_job_info_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+}
+
+static void dump_get_job_info_reply( const struct get_job_info_reply *req )
+{
+    fprintf( stderr, " total_processes=%d", req->total_processes );
+    fprintf( stderr, ", active_processes=%d", req->active_processes );
+}
+
 static void dump_terminate_job_request( const struct terminate_job_request *req )
 {
     fprintf( stderr, " handle=%04x", req->handle );
@@ -4881,6 +4941,7 @@ static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_create_snapshot_request,
     (dump_func)dump_next_process_request,
     (dump_func)dump_next_thread_request,
+    (dump_func)dump_list_processes_request,
     (dump_func)dump_wait_debug_event_request,
     (dump_func)dump_queue_exception_event_request,
     (dump_func)dump_get_exception_status_request,
@@ -5086,6 +5147,7 @@ static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_process_in_job_request,
     (dump_func)dump_set_job_limits_request,
     (dump_func)dump_set_job_completion_port_request,
+    (dump_func)dump_get_job_info_request,
     (dump_func)dump_terminate_job_request,
     (dump_func)dump_suspend_process_request,
     (dump_func)dump_resume_process_request,
@@ -5198,6 +5260,7 @@ static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_create_snapshot_reply,
     (dump_func)dump_next_process_reply,
     (dump_func)dump_next_thread_reply,
+    (dump_func)dump_list_processes_reply,
     (dump_func)dump_wait_debug_event_reply,
     (dump_func)dump_queue_exception_event_reply,
     NULL,
@@ -5387,6 +5450,7 @@ static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {
     NULL,
     NULL,
     NULL,
+    (dump_func)dump_get_job_info_reply,
     NULL,
     NULL,
     NULL,
@@ -5515,6 +5579,7 @@ static const char * const req_names[REQ_NB_REQUESTS] = {
     "create_snapshot",
     "next_process",
     "next_thread",
+    "list_processes",
     "wait_debug_event",
     "queue_exception_event",
     "get_exception_status",
@@ -5720,6 +5785,7 @@ static const char * const req_names[REQ_NB_REQUESTS] = {
     "process_in_job",
     "set_job_limits",
     "set_job_completion_port",
+    "get_job_info",
     "terminate_job",
     "suspend_process",
     "resume_process",
-- 
2.28.0

